{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lib/editor.min.js","webpack:///webpack/bootstrap 80d99595ec113f278b94","webpack:///./src/index.js","webpack:///./src/utils.js","webpack:///./src/caret.js","webpack:///./~/prismjs/prism.js","webpack:///./~/prismjs/components/prism-markdown.js","webpack:///./~/prismjs/plugins/keep-markup/prism-keep-markup.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_utils","_caret","_caret2","_prismjs","_prismjs2","observer","subtree","attributes","childList","characterData","characterDataOldValue","settings","sectionClass","events","change","highlight","Editor","el","options","opts","elm","document","querySelector","HTMLElement","Error","selector","extend","setAttribute","style","whiteSpace","MutationObserver","onMutate","bind","observe","focus","addEventListener","onPaste","mutations","_this","forEach","mutation","type","parentNode","closest","nodes","Array","from","addedNodes","node","className","nodeName","toLowerCase","classList","contains","wrapper","createElement","add","insertBefore","innerText","textContent","set","remove","nodeType","e","paste","clipboardData","getData","path","window","getSelection","console","log","preventDefault","disconnect","pos","get","innerHTML","languages","markdown","start","trigger","text","_this2","sanitizer","sections","toString","split","fragment","createDocumentFragment","section","index","div","appendChild","firstChild","removeChild","textBlocks","childNodes","push","join","nextSibling","callback","hasOwnProperty","attach","apply","arguments","ctx","args","defaults","isNode","Node","_typeof","Symbol","iterator","constructor","parent","range","getRangeAt","startContainer","createTreeWalker","NodeFilter","SHOW_TEXT","acceptNode","FILTER_ACCEPT","treeWalker","sel","end","isBeyondStart","nextNode","currentNode","anchorNode","anchorOffset","isCollapsed","focusNode","focusOffset","currentPos","prevValue","offset","createRange","setStart","collapse","removeAllRanges","addRange","global","_self","WorkerGlobalScope","self","Prism","lang","uniqueId","_","util","encode","tokens","Token","content","alias","map","replace","o","match","objId","clone","v","redef","inside","before","insert","grammar","newToken","ret","token","DFS","visited","plugins","highlightAll","async","env","hooks","run","element","elements","querySelectorAll","highlightElement","language","test","code","Worker","worker","filename","onmessage","evt","highlightedCode","data","postMessage","JSON","stringify","immediateClose","tokenize","strarr","rest","tokenloop","patterns","j","pattern","lookbehind","greedy","lookbehindLength","str","lastIndex","exec","delNum","nextToken","matchedStr","combStr","to","len","slice","after","wrapped","splice","all","name","callbacks","tag","classes","aliases","message","parse","close","script","currentScript","getElementsByTagName","pop","src","hasAttribute","readyState","requestAnimationFrame","markup","comment","prolog","doctype","cdata","punctuation","namespace","attr-value","attr-name","entity","xml","html","mathml","svg","css","atrule","rule","url","string","property","important","function","style-attr","clike","class-name","keyword","boolean","number","operator","javascript","regex","template-string","interpolation","interpolation-punctuation","js","fileHighlight","Extensions","py","rb","ps1","psm1","sh","bat","h","tex","pre","getAttribute","extension","xhr","XMLHttpRequest","open","onreadystatechange","status","responseText","statusText","send","blockquote","title","hr","list","url-reference","variable","bold","italic","KeepMarkup","children","f","elt","baseNode","cloneNode","posOpen","l","child","posClose","keepMarkup","walk","nodeState","nodeStart","nodeStartPos","nodeEnd","nodeEndPos","setEnd","extractContents","insertNode","detach"],"mappings":"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","file":"lib/editor.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Editor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Editor\"] = factory();\n\telse\n\t\troot[\"Editor\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Editor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Editor\"] = factory();\n\telse\n\t\troot[\"Editor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _utils = __webpack_require__(1);\n\t\n\tvar _caret = __webpack_require__(2);\n\t\n\tvar _caret2 = _interopRequireDefault(_caret);\n\t\n\tvar _prismjs = __webpack_require__(3);\n\t\n\tvar _prismjs2 = _interopRequireDefault(_prismjs);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar observer = {\n\t\n\t    subtree: true, // watch mutations from children\n\t    attributes: false,\n\t    childList: true, // watch when children added\n\t    characterData: true,\n\t    characterDataOldValue: true\n\t};\n\t\n\tvar settings = {\n\t\n\t    sectionClass: 'editor__section'\n\t};\n\t\n\tvar events = {\n\t\n\t    change: null,\n\t    highlight: null\n\t};\n\t\n\tvar Editor = function () {\n\t    function Editor(el, options) {\n\t        _classCallCheck(this, Editor);\n\t\n\t        var opts = options || {};\n\t        var elm = document.querySelector(el);\n\t\n\t        if (!(elm instanceof HTMLElement)) {\n\t\n\t            throw new Error('Invalid `el` argument, HTMLElement required');\n\t        }\n\t\n\t        if (!(opts instanceof Object)) {\n\t\n\t            throw new Error('Invalid `options` argument, object required');\n\t        }\n\t\n\t        if (!elm.id) {\n\t\n\t            throw new Error('The element should have an id');\n\t        }\n\t\n\t        this.elm = elm;\n\t        this.selector = el;\n\t        this.settings = (0, _utils.extend)(settings, opts);\n\t\n\t        this.elm.setAttribute('contenteditable', true);\n\t        this.elm.style.whiteSpace = 'pre-wrap';\n\t\n\t        // setup the observers\n\t        this.observer = new MutationObserver(this.onMutate.bind(this));\n\t\n\t        // pass in the target node, as well as the observer options\n\t        this.observer.observe(this.elm, observer);\n\t\n\t        // this.setStartingElement()\n\t\n\t        this.elm.focus();\n\t\n\t        // watch for paste event\n\t        this.elm.addEventListener('paste', this.onPaste.bind(this));\n\t        // this.elm.addEventListener('k', this.onInput.bind(this), true)\n\t\n\t        // \n\t\n\t\n\t        return this;\n\t    }\n\t\n\t    _createClass(Editor, [{\n\t        key: 'onMutate',\n\t        value: function onMutate(mutations) {\n\t            var _this = this;\n\t\n\t            mutations.forEach(function (mutation) {\n\t\n\t                if (mutation.type == 'characterData') {\n\t\n\t                    var target = mutation.target.parentNode;\n\t\n\t                    if (target) {\n\t\n\t                        // look for the closest wrapping div ('#editor > div')\n\t                        var closest = target.closest('.editor__section');\n\t\n\t                        if (closest) {\n\t\n\t                            _this.highlight(closest);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                if (mutation.type == 'childList') {\n\t                    // only look for mutations on the parent #editor element\n\t                    if (mutation.target.id == _this.elm.id) {\n\t\n\t                        var nodes = Array.from(mutation.addedNodes);\n\t\n\t                        nodes.forEach(function (node) {\n\t\n\t                            // if node is added check if it's actually a section\n\t                            if (node && node.className != _this.settings.sectionClass) {\n\t\n\t                                if (node.nodeName.toLowerCase() != 'div' || !node.classList.contains(_this.settings.sectionClass)) {\n\t\n\t                                    // replace the falsy section with the right node\n\t                                    var wrapper = document.createElement('div');\n\t                                    wrapper.classList.add(_this.settings.sectionClass, 'markdown');\n\t                                    node.parentNode.insertBefore(wrapper, node);\n\t                                    // wrapper.innerText = node.textContent.length > 0 ? node.textContent : '\\r'\n\t                                    wrapper.innerText = node.textContent;\n\t\n\t                                    _caret2.default.set(wrapper, wrapper.textContent.length);\n\t                                    node.remove();\n\t                                }\n\t                            }\n\t\n\t                            if (node.nodeType == 1) {\n\t\n\t                                _this.highlight(node);\n\t                            }\n\t                        });\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    }, {\n\t        key: 'onPaste',\n\t        value: function onPaste(e) {\n\t\n\t            // @TODO: paste logic should become as following:\n\t            // - get this.elm.innerText\n\t            // - sanitize the paste data (if the data is coming externally)\n\t            // - convert line breaks to sections (if the data is coming externally)\n\t            // - substite the selection (if any?, window.getSelection().toString()) from the innerText with the paste data\n\t            // - insert text in full editor\n\t            //  NOTE: to see if the paste data is coming externally we could create a copy event\n\t            //  inside the editor. When the copy data is the same as the paste, the data is internal\n\t\n\t            // this might not be the most efficient way to implement \n\t            // pasting but for now the lesser evil\n\t\n\t            var paste = e.clipboardData.getData('text/plain');\n\t            var node = e.path[0];\n\t\n\t            if (window.getSelection() == paste) {\n\t\n\t                console.log('ok');\n\t            }\n\t\n\t            e.preventDefault;\n\t        }\n\t    }, {\n\t        key: 'highlight',\n\t        value: function highlight(node) {\n\t\n\t            if (node) {\n\t\n\t                this.observer.disconnect();\n\t                var pos = _caret2.default.get(node);\n\t                node.innerHTML = _prismjs2.default.highlight(node.innerText, _prismjs2.default.languages.markdown);\n\t                _caret2.default.set(node, pos.start);\n\t                this.observer.observe(this.elm, observer);\n\t                this.trigger('change', this);\n\t            }\n\t        }\n\t\n\t        //@TODO: create different setText methods for paste and new text\n\t\n\t    }, {\n\t        key: 'setText',\n\t        value: function setText(text) {\n\t            var _this2 = this;\n\t\n\t            // create an empty element to paste the text in\n\t            // so it can be sanitized and escaped\n\t            var sanitizer = document.createElement('textarea');\n\t            sanitizer.value = text;\n\t\n\t            // stop the observer while creating elements or the document will freeze!\n\t            this.observer.disconnect();\n\t\n\t            var sections = sanitizer.value.toString().split(/\\f/);\n\t\n\t            var fragment = document.createDocumentFragment();\n\t\n\t            sections.forEach(function (section, index) {\n\t\n\t                var div = document.createElement('div');\n\t                div.classList.add(_this2.settings.sectionClass, 'markdown');\n\t                div.innerHTML = _prismjs2.default.highlight(section, _prismjs2.default.languages.markdown);\n\t                // div.innerText = section\n\t                // hljs.highlightBlock(div)\n\t                fragment.appendChild(div);\n\t            });\n\t\n\t            // remove all elements from the editor\n\t            while (this.elm.firstChild) {\n\t\n\t                this.elm.removeChild(this.elm.firstChild);\n\t            }\n\t\n\t            this.elm.appendChild(fragment);\n\t\n\t            this.observer.observe(this.elm, observer);\n\t        }\n\t    }, {\n\t        key: 'setNode',\n\t        value: function setNode(node, value) {\n\t\n\t            node.innerHTML = value;\n\t        }\n\t    }, {\n\t        key: 'getHTML',\n\t        value: function getHTML() {\n\t\n\t            return this.elm.innerHTML;\n\t        }\n\t    }, {\n\t        key: 'inView',\n\t        value: function inView() {}\n\t    }, {\n\t        key: 'getTextForStorage',\n\t        value: function getTextForStorage() {\n\t\n\t            var textBlocks = [];\n\t\n\t            var nodes = Array.from(this.elm.childNodes);\n\t\n\t            nodes.forEach(function (e) {\n\t\n\t                textBlocks.push(e.innerText);\n\t            });\n\t\n\t            return textBlocks.join('\\f');\n\t        }\n\t    }, {\n\t        key: 'getText',\n\t        value: function getText() {\n\t\n\t            return this.elm.innerText;\n\t        }\n\t    }, {\n\t        key: 'getCaret',\n\t        value: function getCaret() {\n\t\n\t            return _caret2.default.get(this.elm);\n\t        }\n\t    }, {\n\t        key: 'setStartingElement',\n\t        value: function setStartingElement() {\n\t\n\t            // there are no children yet so create one\n\t            if (this.elm.firstChild == null) {\n\t\n\t                var div = document.createElement('div');\n\t                this.elm.appendChild(div);\n\t\n\t                // there is a first node but it's not a div\n\t            } else if (this.elm.firstChild.nodeName.toLowerCase() != 'div') {\n\t\n\t                var _div = document.createElement('div');\n\t                this.elm.insertBefore(_div, this.elm.firstChild);\n\t                this.elm.firstChild.nextSibling.remove();\n\t                _caret2.default.set(_div, 0);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'attach',\n\t        value: function attach(e, callback) {\n\t\n\t            if (events.hasOwnProperty(e)) {\n\t\n\t                if (typeof callback == 'function') {\n\t\n\t                    events[e] = callback;\n\t                } else {\n\t\n\t                    throw new Error('Event callback must be a function');\n\t                }\n\t            } else {\n\t\n\t                throw new Error('No support for the event: ' + e);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'on',\n\t        value: function on(e, callback) {\n\t\n\t            // arguments = e, callback \n\t            this.attach.apply(this, arguments);\n\t        }\n\t    }, {\n\t        key: 'trigger',\n\t        value: function trigger(e, ctx, args) {\n\t\n\t            if (events[e]) {\n\t\n\t                events[e].call(ctx, args);\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return Editor;\n\t}();\n\t\n\texports.default = Editor;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.extend = extend;\n\texports.isNode = isNode;\n\tfunction extend(defaults, options) {\n\t\n\t    for (var key in options) {\n\t\n\t        if (Object.prototype.hasOwnProperty.call(options, key)) {\n\t\n\t            defaults[key] = options[key];\n\t        }\n\t    }\n\t\n\t    return defaults;\n\t}\n\t\n\tfunction isNode(node) {\n\t\n\t    return (typeof Node === \"undefined\" ? \"undefined\" : _typeof(Node)) === \"object\" ? node instanceof Node : node && (typeof node === \"undefined\" ? \"undefined\" : _typeof(node)) === \"object\" && typeof node.nodeType === \"number\" && typeof node.nodeName === \"string\";\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar parent = function parent(node) {\n\t\n\t    var range = window.getSelection().getRangeAt(0);\n\t\n\t    return range.startContainer.parentNode;\n\t};\n\t\n\tvar createTreeWalker = function createTreeWalker(node) {\n\t\n\t    return document.createTreeWalker(node, // define the root\n\t    NodeFilter.SHOW_TEXT, // only textnodes\n\t    {\n\t        acceptNode: function acceptNode(node) {\n\t\n\t            // by default accepts all nodes that are of type text\n\t            return NodeFilter.FILTER_ACCEPT;\n\t        }\n\t    }, false);\n\t};\n\t\n\tvar get = function get(node) {\n\t\n\t    var treeWalker = createTreeWalker(node);\n\t    var sel = window.getSelection();\n\t\n\t    var pos = {\n\t\n\t        start: 0,\n\t        end: 0\n\t    };\n\t\n\t    var isBeyondStart = false;\n\t\n\t    while (treeWalker.nextNode()) {\n\t\n\t        // anchorNode is where the selection starts\n\t        if (!isBeyondStart && treeWalker.currentNode === sel.anchorNode) {\n\t\n\t            isBeyondStart = true;\n\t\n\t            pos.start += sel.anchorOffset;\n\t\n\t            if (sel.isCollapsed) {\n\t\n\t                pos.end = pos.start;\n\t                break;\n\t            }\n\t        } else if (!isBeyondStart) {\n\t\n\t            pos.start += treeWalker.currentNode.length;\n\t        }\n\t\n\t        if (!sel.isCollapsed && treeWalker.currentNode === sel.focusNode) {\n\t\n\t            pos.end += sel.focusOffset;\n\t            break;\n\t        } else if (!sel.isCollapsed) {\n\t\n\t            pos.end += treeWalker.currentNode.length;\n\t        }\n\t    }\n\t\n\t    return pos;\n\t};\n\t\n\tvar set = function set(node, index) {\n\t\n\t    var treeWalker = createTreeWalker(node);\n\t    var currentPos = 0;\n\t\n\t    while (treeWalker.nextNode()) {\n\t\n\t        currentPos += treeWalker.currentNode.length;\n\t\n\t        if (currentPos >= index) {\n\t\n\t            var prevValue = currentPos - treeWalker.currentNode.length;\n\t            var offset = index - prevValue;\n\t\n\t            var range = document.createRange();\n\t\n\t            range.setStart(treeWalker.currentNode, offset);\n\t            range.collapse(true);\n\t\n\t            var sel = window.getSelection();\n\t            sel.removeAllRanges();\n\t            sel.addRange(range);\n\t\n\t            break;\n\t        }\n\t    }\n\t};\n\t\n\texports.default = {\n\t\n\t    get: get,\n\t    set: set,\n\t    parent: parent\n\t};\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/* **********************************************\n\t     Begin prism-core.js\n\t********************************************** */\n\t\n\tvar _self = (typeof window !== 'undefined')\n\t\t? window   // if in browser\n\t\t: (\n\t\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t\t);\n\t\n\t/**\n\t * Prism: Lightweight, robust, elegant syntax highlighting\n\t * MIT license http://www.opensource.org/licenses/mit-license.php/\n\t * @author Lea Verou http://lea.verou.me\n\t */\n\t\n\tvar Prism = (function(){\n\t\n\t// Private helper vars\n\tvar lang = /\\blang(?:uage)?-(\\w+)\\b/i;\n\tvar uniqueId = 0;\n\t\n\tvar _ = _self.Prism = {\n\t\tutil: {\n\t\t\tencode: function (tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (_.util.type(tokens) === 'Array') {\n\t\t\t\t\treturn tokens.map(_.util.encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n\t\t\t},\n\t\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\t\n\t\t\t// Deep clone a language definition (e.g. to extend it)\n\t\t\tclone: function (o) {\n\t\t\t\tvar type = _.util.type(o);\n\t\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tvar clone = {};\n\t\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn clone;\n\t\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\t// Check for existence for IE8\n\t\t\t\t\t\treturn o.map && o.map(function(v) { return _.util.clone(v); });\n\t\t\t\t}\n\t\n\t\t\t\treturn o;\n\t\t\t}\n\t\t},\n\t\n\t\tlanguages: {\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\t\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\t\n\t\t\t\treturn lang;\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Insert a token before another token in a language literal\n\t\t\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n\t\t\t * we cannot just provide an object, we need anobject and a key.\n\t\t\t * @param inside The key (or language id) of the parent\n\t\t\t * @param before The key to insert before. If not provided, the function appends instead.\n\t\t\t * @param insert Object with the key/value pairs to insert\n\t\t\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || _.languages;\n\t\t\t\tvar grammar = root[inside];\n\t\n\t\t\t\tif (arguments.length == 2) {\n\t\t\t\t\tinsert = arguments[1];\n\t\n\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\tgrammar[newToken] = insert[newToken];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn grammar;\n\t\t\t\t}\n\t\n\t\t\t\tvar ret = {};\n\t\n\t\t\t\tfor (var token in grammar) {\n\t\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\t\n\t\t\t\t\t\tif (token == before) {\n\t\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function(key, value) {\n\t\t\t\t\tif (value === root[inside] && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\treturn root[inside] = ret;\n\t\t\t},\n\t\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\t\n\t\t\t\t\t\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t\t_.languages.DFS(o[i], callback, null, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t\t_.languages.DFS(o[i], callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tplugins: {},\n\t\n\t\thighlightAll: function(async, callback) {\n\t\t\tvar env = {\n\t\t\t\tcallback: callback,\n\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t\t};\n\t\n\t\t\t_.hooks.run(\"before-highlightall\", env);\n\t\n\t\t\tvar elements = env.elements || document.querySelectorAll(env.selector);\n\t\n\t\t\tfor (var i=0, element; element = elements[i++];) {\n\t\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t\t}\n\t\t},\n\t\n\t\thighlightElement: function(element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language, grammar, parent = element;\n\t\n\t\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\t\n\t\t\tif (parent) {\n\t\t\t\tlanguage = (parent.className.match(lang) || [,''])[1].toLowerCase();\n\t\t\t\tgrammar = _.languages[language];\n\t\t\t}\n\t\n\t\t\t// Set language on the element, if not present\n\t\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\n\t\t\t// Set language on the parent, for styling\n\t\t\tparent = element.parentNode;\n\t\n\t\t\tif (/pre/i.test(parent.nodeName)) {\n\t\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\t\t}\n\t\n\t\t\tvar code = element.textContent;\n\t\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\t\n\t\t\t_.hooks.run('before-sanity-check', env);\n\t\n\t\t\tif (!env.code || !env.grammar) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t_.hooks.run('before-highlight', env);\n\t\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\t\n\t\t\t\tworker.onmessage = function(evt) {\n\t\t\t\t\tenv.highlightedCode = evt.data;\n\t\n\t\t\t\t\t_.hooks.run('before-insert', env);\n\t\n\t\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\t\n\t\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\t};\n\t\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\t\n\t\t\t\t_.hooks.run('before-insert', env);\n\t\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\t\n\t\t\t\tcallback && callback.call(element);\n\t\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t}\n\t\t},\n\t\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar tokens = _.tokenize(text, grammar);\n\t\t\treturn Token.stringify(_.util.encode(tokens), language);\n\t\t},\n\t\n\t\ttokenize: function(text, grammar, language) {\n\t\t\tvar Token = _.Token;\n\t\n\t\t\tvar strarr = [text];\n\t\n\t\t\tvar rest = grammar.rest;\n\t\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\t\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\t\n\t\t\ttokenloop: for (var token in grammar) {\n\t\t\t\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tvar patterns = grammar[token];\n\t\t\t\tpatterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n\t\n\t\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\t\tvar pattern = patterns[j],\n\t\t\t\t\t\tinside = pattern.inside,\n\t\t\t\t\t\tlookbehind = !!pattern.lookbehind,\n\t\t\t\t\t\tgreedy = !!pattern.greedy,\n\t\t\t\t\t\tlookbehindLength = 0,\n\t\t\t\t\t\talias = pattern.alias;\n\t\n\t\t\t\t\tpattern = pattern.pattern || pattern;\n\t\n\t\t\t\t\tfor (var i=0; i<strarr.length; i++) { // Don’t cache length as it changes during the loop\n\t\n\t\t\t\t\t\tvar str = strarr[i];\n\t\n\t\t\t\t\t\tif (strarr.length > text.length) {\n\t\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\t\tbreak tokenloop;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tpattern.lastIndex = 0;\n\t\n\t\t\t\t\t\tvar match = pattern.exec(str),\n\t\t\t\t\t\t    delNum = 1;\n\t\n\t\t\t\t\t\t// Greedy patterns can override/remove up to two previously matched tokens\n\t\t\t\t\t\tif (!match && greedy && i != strarr.length - 1) {\n\t\t\t\t\t\t\t// Reconstruct the original text using the next two tokens\n\t\t\t\t\t\t\tvar nextToken = strarr[i + 1].matchedStr || strarr[i + 1],\n\t\t\t\t\t\t\t    combStr = str + nextToken;\n\t\n\t\t\t\t\t\t\tif (i < strarr.length - 2) {\n\t\t\t\t\t\t\t\tcombStr += strarr[i + 2].matchedStr || strarr[i + 2];\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Try the pattern again on the reconstructed text\n\t\t\t\t\t\t\tpattern.lastIndex = 0;\n\t\t\t\t\t\t\tmatch = pattern.exec(combStr);\n\t\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar from = match.index + (lookbehind ? match[1].length : 0);\n\t\t\t\t\t\t\t// To be a valid candidate, the new match has to start inside of str\n\t\t\t\t\t\t\tif (from >= str.length) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar to = match.index + match[0].length,\n\t\t\t\t\t\t\t    len = str.length + nextToken.length;\n\t\n\t\t\t\t\t\t\t// Number of tokens to delete and replace with the new match\n\t\t\t\t\t\t\tdelNum = 3;\n\t\n\t\t\t\t\t\t\tif (to <= len) {\n\t\t\t\t\t\t\t\tif (strarr[i + 1].greedy) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdelNum = 2;\n\t\t\t\t\t\t\t\tcombStr = combStr.slice(0, len);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstr = combStr;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(lookbehind) {\n\t\t\t\t\t\t\tlookbehindLength = match[1].length;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar from = match.index + lookbehindLength,\n\t\t\t\t\t\t    match = match[0].slice(lookbehindLength),\n\t\t\t\t\t\t    to = from + match.length,\n\t\t\t\t\t\t    before = str.slice(0, from),\n\t\t\t\t\t\t    after = str.slice(to);\n\t\n\t\t\t\t\t\tvar args = [i, delNum];\n\t\n\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\targs.push(before);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);\n\t\n\t\t\t\t\t\targs.push(wrapped);\n\t\n\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\targs.push(after);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tArray.prototype.splice.apply(strarr, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn strarr;\n\t\t},\n\t\n\t\thooks: {\n\t\t\tall: {},\n\t\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\t\n\t\t\t\thooks[name] = hooks[name] || [];\n\t\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\t\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\t\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tfor (var i=0, callback; callback = callbacks[i++];) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar Token = _.Token = function(type, content, alias, matchedStr, greedy) {\n\t\tthis.type = type;\n\t\tthis.content = content;\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.matchedStr = matchedStr || null;\n\t\tthis.greedy = !!greedy;\n\t};\n\t\n\tToken.stringify = function(o, language, parent) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\n\t\tif (_.util.type(o) === 'Array') {\n\t\t\treturn o.map(function(element) {\n\t\t\t\treturn Token.stringify(element, language, o);\n\t\t\t}).join('');\n\t\t}\n\t\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: Token.stringify(o.content, language, parent),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language,\n\t\t\tparent: parent\n\t\t};\n\t\n\t\tif (env.type == 'comment') {\n\t\t\tenv.attributes['spellcheck'] = 'true';\n\t\t}\n\t\n\t\tif (o.alias) {\n\t\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t}\n\t\n\t\t_.hooks.run('wrap', env);\n\t\n\t\tvar attributes = '';\n\t\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += (attributes ? ' ' : '') + name + '=\"' + (env.attributes[name] || '') + '\"';\n\t\t}\n\t\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t\n\t};\n\t\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _self.Prism;\n\t\t}\n\t \t// In worker\n\t\t_self.addEventListener('message', function(evt) {\n\t\t\tvar message = JSON.parse(evt.data),\n\t\t\t    lang = message.language,\n\t\t\t    code = message.code,\n\t\t\t    immediateClose = message.immediateClose;\n\t\n\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\tif (immediateClose) {\n\t\t\t\t_self.close();\n\t\t\t}\n\t\t}, false);\n\t\n\t\treturn _self.Prism;\n\t}\n\t\n\t//Get current script and highlight\n\tvar script = document.currentScript || [].slice.call(document.getElementsByTagName(\"script\")).pop();\n\t\n\tif (script) {\n\t\t_.filename = script.src;\n\t\n\t\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\n\t\t\tif(document.readyState !== \"loading\") {\n\t\t\t\trequestAnimationFrame(_.highlightAll, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn _self.Prism;\n\t\n\t})();\n\t\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = Prism;\n\t}\n\t\n\t// hack for components to work correctly in node.js\n\tif (typeof global !== 'undefined') {\n\t\tglobal.Prism = Prism;\n\t}\n\t\n\t\n\t/* **********************************************\n\t     Begin prism-markup.js\n\t********************************************** */\n\t\n\tPrism.languages.markup = {\n\t\t'comment': /<!--[\\w\\W]*?-->/,\n\t\t'prolog': /<\\?[\\w\\W]+?\\?>/,\n\t\t'doctype': /<!DOCTYPE[\\w\\W]+?>/,\n\t\t'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n\t\t'tag': {\n\t\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=.$<]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\\\1|\\\\?(?!\\1)[\\w\\W])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,\n\t\t\tinside: {\n\t\t\t\t'tag': {\n\t\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/i,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /[=>\"']/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\/?>/,\n\t\t\t\t'attr-name': {\n\t\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t},\n\t\t'entity': /&#?[\\da-z]{1,8};/i\n\t};\n\t\n\t// Plugin to make entity title show the real entity, idea by Roman Komarov\n\tPrism.hooks.add('wrap', function(env) {\n\t\n\t\tif (env.type === 'entity') {\n\t\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t\t}\n\t});\n\t\n\tPrism.languages.xml = Prism.languages.markup;\n\tPrism.languages.html = Prism.languages.markup;\n\tPrism.languages.mathml = Prism.languages.markup;\n\tPrism.languages.svg = Prism.languages.markup;\n\t\n\t\n\t/* **********************************************\n\t     Begin prism-css.js\n\t********************************************** */\n\t\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\w\\W]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n\t\t\tinside: {\n\t\t\t\t'rule': /@[\\w-]+/\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': /url\\((?:([\"'])(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1|.*?)\\)/i,\n\t\t'selector': /[^\\{\\}\\s][^\\{\\};]*?(?=\\s*\\{)/,\n\t\t'string': /(\"|')(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\t'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n\t\t'important': /\\B!important\\b/i,\n\t\t'function': /[-a-z0-9]+(?=\\()/i,\n\t\t'punctuation': /[(){};:]/\n\t};\n\t\n\tPrism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);\n\t\n\tif (Prism.languages.markup) {\n\t\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t\t'style': {\n\t\t\t\tpattern: /(<style[\\w\\W]*?>)[\\w\\W]*?(?=<\\/style>)/i,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.css,\n\t\t\t\talias: 'language-css'\n\t\t\t}\n\t\t});\n\t\t\n\t\tPrism.languages.insertBefore('inside', 'attr-value', {\n\t\t\t'style-attr': {\n\t\t\t\tpattern: /\\s*style=(\"|').*?\\1/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'attr-name': {\n\t\t\t\t\t\tpattern: /^\\s*style/i,\n\t\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t\t},\n\t\t\t\t\t'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n\t\t\t\t\t'attr-value': {\n\t\t\t\t\t\tpattern: /.+/i,\n\t\t\t\t\t\tinside: Prism.languages.css\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\talias: 'language-css'\n\t\t\t}\n\t\t}, Prism.languages.markup.tag);\n\t}\n\t\n\t/* **********************************************\n\t     Begin prism-clike.js\n\t********************************************** */\n\t\n\tPrism.languages.clike = {\n\t\t'comment': [\n\t\t\t{\n\t\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'string': {\n\t\t\tpattern: /([\"'])(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'class-name': {\n\t\t\tpattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tpunctuation: /(\\.|\\\\)/\n\t\t\t}\n\t\t},\n\t\t'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n\t\t'boolean': /\\b(true|false)\\b/,\n\t\t'function': /[a-z0-9_]+(?=\\()/i,\n\t\t'number': /\\b-?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+-]?\\d+)?)\\b/i,\n\t\t'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n\t\t'punctuation': /[{}[\\];(),.:]/\n\t};\n\t\n\t\n\t/* **********************************************\n\t     Begin prism-javascript.js\n\t********************************************** */\n\t\n\tPrism.languages.javascript = Prism.languages.extend('clike', {\n\t\t'keyword': /\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,\n\t\t'number': /\\b-?(0x[\\dA-Fa-f]+|0b[01]+|0o[0-7]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|Infinity)\\b/,\n\t\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t\t'function': /[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*(?=\\()/i\n\t});\n\t\n\tPrism.languages.insertBefore('javascript', 'keyword', {\n\t\t'regex': {\n\t\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\\\\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('javascript', 'string', {\n\t\t'template-string': {\n\t\t\tpattern: /`(?:\\\\\\\\|\\\\?[^\\\\])*?`/,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /\\$\\{[^}]+\\}/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t\t},\n\t\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t}\n\t});\n\t\n\tif (Prism.languages.markup) {\n\t\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t\t'script': {\n\t\t\t\tpattern: /(<script[\\w\\W]*?>)[\\w\\W]*?(?=<\\/script>)/i,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.javascript,\n\t\t\t\talias: 'language-javascript'\n\t\t\t}\n\t\t});\n\t}\n\t\n\tPrism.languages.js = Prism.languages.javascript;\n\t\n\t/* **********************************************\n\t     Begin prism-file-highlight.js\n\t********************************************** */\n\t\n\t(function () {\n\t\tif (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tself.Prism.fileHighlight = function() {\n\t\n\t\t\tvar Extensions = {\n\t\t\t\t'js': 'javascript',\n\t\t\t\t'py': 'python',\n\t\t\t\t'rb': 'ruby',\n\t\t\t\t'ps1': 'powershell',\n\t\t\t\t'psm1': 'powershell',\n\t\t\t\t'sh': 'bash',\n\t\t\t\t'bat': 'batch',\n\t\t\t\t'h': 'c',\n\t\t\t\t'tex': 'latex'\n\t\t\t};\n\t\n\t\t\tif(Array.prototype.forEach) { // Check to prevent error in IE8\n\t\t\t\tArray.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {\n\t\t\t\t\tvar src = pre.getAttribute('data-src');\n\t\n\t\t\t\t\tvar language, parent = pre;\n\t\t\t\t\tvar lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\t\t\t\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\t\t\t\tparent = parent.parentNode;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tlanguage = (pre.className.match(lang) || [, ''])[1];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (!language) {\n\t\t\t\t\t\tvar extension = (src.match(/\\.(\\w+)$/) || [, ''])[1];\n\t\t\t\t\t\tlanguage = Extensions[extension] || extension;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar code = document.createElement('code');\n\t\t\t\t\tcode.className = 'language-' + language;\n\t\n\t\t\t\t\tpre.textContent = '';\n\t\n\t\t\t\t\tcode.textContent = 'Loading…';\n\t\n\t\t\t\t\tpre.appendChild(code);\n\t\n\t\t\t\t\tvar xhr = new XMLHttpRequest();\n\t\n\t\t\t\t\txhr.open('GET', src, true);\n\t\n\t\t\t\t\txhr.onreadystatechange = function () {\n\t\t\t\t\t\tif (xhr.readyState == 4) {\n\t\n\t\t\t\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\t\t\t\tcode.textContent = xhr.responseText;\n\t\n\t\t\t\t\t\t\t\tPrism.highlightElement(code);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xhr.status >= 400) {\n\t\t\t\t\t\t\t\tcode.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tcode.textContent = '✖ Error: File does not exist or is empty';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\n\t\t\t\t\txhr.send(null);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tdocument.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);\n\t\n\t})();\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tPrism.languages.markdown = Prism.languages.extend('markup', {});\n\tPrism.languages.insertBefore('markdown', 'prolog', {\n\t\t'blockquote': {\n\t\t\t// > ...\n\t\t\tpattern: /^>(?:[\\t ]*>)*/m,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'code': [\n\t\t\t{\n\t\t\t\t// Prefixed by 4 spaces or 1 tab\n\t\t\t\tpattern: /^(?: {4}|\\t).+/m,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t{\n\t\t\t\t// `code`\n\t\t\t\t// ``code``\n\t\t\t\tpattern: /``.+?``|`[^`\\n]+`/,\n\t\t\t\talias: 'keyword'\n\t\t\t}\n\t\t],\n\t\t'title': [\n\t\t\t{\n\t\t\t\t// title 1\n\t\t\t\t// =======\n\t\n\t\t\t\t// title 2\n\t\t\t\t// -------\n\t\t\t\tpattern: /\\w+.*(?:\\r?\\n|\\r)(?:==+|--+)/,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /==+$|--+$/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t// # title 1\n\t\t\t\t// ###### title 6\n\t\t\t\tpattern: /(^\\s*)#+.+/m,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /^#+|#+$/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'hr': {\n\t\t\t// ***\n\t\t\t// ---\n\t\t\t// * * *\n\t\t\t// -----------\n\t\t\tpattern: /(^\\s*)([*-])([\\t ]*\\2){2,}(?=\\s*$)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'list': {\n\t\t\t// * item\n\t\t\t// + item\n\t\t\t// - item\n\t\t\t// 1. item\n\t\t\tpattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'url-reference': {\n\t\t\t// [id]: http://example.com \"Optional title\"\n\t\t\t// [id]: http://example.com 'Optional title'\n\t\t\t// [id]: http://example.com (Optional title)\n\t\t\t// [id]: <http://example.com> \"Optional title\"\n\t\t\tpattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n\t\t\tinside: {\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /^(!?\\[)[^\\]]+/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n\t\t\t\t'punctuation': /^[\\[\\]!:]|[<>]/\n\t\t\t},\n\t\t\talias: 'url'\n\t\t},\n\t\t'bold': {\n\t\t\t// **strong**\n\t\t\t// __strong__\n\t\n\t\t\t// Allow only one line break\n\t\t\tpattern: /(^|[^\\\\])(\\*\\*|__)(?:(?:\\r?\\n|\\r)(?!\\r?\\n|\\r)|.)+?\\2/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^\\*\\*|^__|\\*\\*$|__$/\n\t\t\t}\n\t\t},\n\t\t'italic': {\n\t\t\t// *em*\n\t\t\t// _em_\n\t\n\t\t\t// Allow only one line break\n\t\t\tpattern: /(^|[^\\\\])([*_])(?:(?:\\r?\\n|\\r)(?!\\r?\\n|\\r)|.)+?\\2/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^[*_]|[*_]$/\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// [example](http://example.com \"Optional title\")\n\t\t\t// [example] [id]\n\t\t\tpattern: /!?\\[[^\\]]+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)| ?\\[[^\\]\\n]*\\])/,\n\t\t\tinside: {\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /(!?\\[)[^\\]]+(?=\\]$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: /\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\tPrism.languages.markdown['bold'].inside['url'] = Prism.util.clone(Prism.languages.markdown['url']);\n\tPrism.languages.markdown['italic'].inside['url'] = Prism.util.clone(Prism.languages.markdown['url']);\n\tPrism.languages.markdown['bold'].inside['italic'] = Prism.util.clone(Prism.languages.markdown['italic']);\n\tPrism.languages.markdown['italic'].inside['bold'] = Prism.util.clone(Prism.languages.markdown['bold']);\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t\n\t\tif (typeof self === 'undefined' || !self.Prism || !self.document || !document.createRange) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tPrism.plugins.KeepMarkup = true;\n\t\n\t\tPrism.hooks.add('before-highlight', function (env) {\n\t\t\tif (!env.element.children.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar pos = 0;\n\t\t\tvar data = [];\n\t\t\tvar f = function (elt, baseNode) {\n\t\t\t\tvar o = {};\n\t\t\t\tif (!baseNode) {\n\t\t\t\t\t// Clone the original tag to keep all attributes\n\t\t\t\t\to.clone = elt.cloneNode(false);\n\t\t\t\t\to.posOpen = pos;\n\t\t\t\t\tdata.push(o);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0, l = elt.childNodes.length; i < l; i++) {\n\t\t\t\t\tvar child = elt.childNodes[i];\n\t\t\t\t\tif (child.nodeType === 1) { // element\n\t\t\t\t\t\tf(child);\n\t\t\t\t\t} else if(child.nodeType === 3) { // text\n\t\t\t\t\t\tpos += child.data.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!baseNode) {\n\t\t\t\t\to.posClose = pos;\n\t\t\t\t}\n\t\t\t};\n\t\t\tf(env.element, true);\n\t\n\t\t\tif (data && data.length) {\n\t\t\t\t// data is an array of all existing tags\n\t\t\t\tenv.keepMarkup = data;\n\t\t\t}\n\t\t});\n\t\n\t\tPrism.hooks.add('after-highlight', function (env) {\n\t\t\tif(env.keepMarkup && env.keepMarkup.length) {\n\t\n\t\t\t\tvar walk = function (elt, nodeState) {\n\t\t\t\t\tfor (var i = 0, l = elt.childNodes.length; i < l; i++) {\n\t\n\t\t\t\t\t\tvar child = elt.childNodes[i];\n\t\n\t\t\t\t\t\tif (child.nodeType === 1) { // element\n\t\t\t\t\t\t\tif (!walk(child, nodeState)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if (child.nodeType === 3) { // text\n\t\t\t\t\t\t\tif(!nodeState.nodeStart && nodeState.pos + child.data.length > nodeState.node.posOpen) {\n\t\t\t\t\t\t\t\t// We found the start position\n\t\t\t\t\t\t\t\tnodeState.nodeStart = child;\n\t\t\t\t\t\t\t\tnodeState.nodeStartPos = nodeState.node.posOpen - nodeState.pos;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(nodeState.nodeStart && nodeState.pos + child.data.length >= nodeState.node.posClose) {\n\t\t\t\t\t\t\t\t// We found the end position\n\t\t\t\t\t\t\t\tnodeState.nodeEnd = child;\n\t\t\t\t\t\t\t\tnodeState.nodeEndPos = nodeState.node.posClose - nodeState.pos;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tnodeState.pos += child.data.length;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (nodeState.nodeStart && nodeState.nodeEnd) {\n\t\t\t\t\t\t\t// Select the range and wrap it with the clone\n\t\t\t\t\t\t\tvar range = document.createRange();\n\t\t\t\t\t\t\trange.setStart(nodeState.nodeStart, nodeState.nodeStartPos);\n\t\t\t\t\t\t\trange.setEnd(nodeState.nodeEnd, nodeState.nodeEndPos);\n\t\t\t\t\t\t\tnodeState.node.clone.appendChild(range.extractContents());\n\t\t\t\t\t\t\trange.insertNode(nodeState.node.clone);\n\t\t\t\t\t\t\trange.detach();\n\t\n\t\t\t\t\t\t\t// Process is over\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t};\n\t\n\t\t\t\t// For each tag, we walk the DOM to reinsert it\n\t\t\t\tenv.keepMarkup.forEach(function (node) {\n\t\t\t\t\twalk(env.element, {\n\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\tpos: 0\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}());\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** lib/editor.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 80d99595ec113f278b94\n **/","import {extend, isNode} from './utils'\nimport caret from './caret'\nimport Prism from 'prismjs'\nimport 'prismjs/components/prism-markdown'\nimport 'prismjs/plugins/keep-markup/prism-keep-markup'\n\nconst observer = {\n\n    subtree: true,                  // watch mutations from children\n    attributes: false,\n    childList: true,               // watch when children added\n    characterData: true,\n    characterDataOldValue: true\n}\n\nconst settings = {\n\n    sectionClass: 'editor__section'\n}\n\nconst events = {\n    \n    change: null,\n    highlight: null\n}\n\nclass Editor {\n\n    constructor(el, options) {\n        \n        const opts = options || {}\n        const elm = document.querySelector(el)\n        \n        if (!(elm instanceof HTMLElement)) {\n\n            throw new Error('Invalid `el` argument, HTMLElement required');\n        }\n\n        if (!(opts instanceof Object)) {\n            \n            throw new Error('Invalid `options` argument, object required');\n        }\n\n        if (!elm.id) {\n\n            throw new Error('The element should have an id')\n        }\n\n        this.elm = elm\n        this.selector = el\n        this.settings = extend(settings, opts)\n\n        this.elm.setAttribute('contenteditable', true)\n        this.elm.style.whiteSpace = 'pre-wrap'\n        \n        // setup the observers\n        this.observer = new MutationObserver(this.onMutate.bind(this))\n\n        // pass in the target node, as well as the observer options\n        this.observer.observe(this.elm, observer);\n\n        // this.setStartingElement()\n\n        this.elm.focus()\n\n\n        // watch for paste event\n        this.elm.addEventListener('paste', this.onPaste.bind(this))\n        // this.elm.addEventListener('k', this.onInput.bind(this), true)\n\n// \n        \n       \n\n        return this\n    }\n\n    onMutate(mutations) {\n\n        mutations.forEach((mutation) => {\n\n            if (mutation.type == 'characterData') {\n                \n                const target = mutation.target.parentNode\n\n                if (target) {\n\n                    // look for the closest wrapping div ('#editor > div')\n                    const closest = target.closest('.editor__section')\n\n                    if (closest) {\n\n                        this.highlight(closest)\n                    }\n                }\n            }\n\n            if (mutation.type == 'childList') {\n                // only look for mutations on the parent #editor element\n                if (mutation.target.id == this.elm.id) {\n                    \n                    const nodes = Array.from(mutation.addedNodes)\n\n                    nodes.forEach((node) => {\n\n                        // if node is added check if it's actually a section\n                        if(node && node.className != this.settings.sectionClass) {\n\n                            if (node.nodeName.toLowerCase() != 'div'    \n                                || !node.classList.contains(this.settings.sectionClass)) {\n\n                                // replace the falsy section with the right node\n                                const wrapper = document.createElement('div')\n                                wrapper.classList.add(this.settings.sectionClass, 'markdown')\n                                node.parentNode.insertBefore(wrapper, node)\n                                // wrapper.innerText = node.textContent.length > 0 ? node.textContent : '\\r'\n                                wrapper.innerText = node.textContent;\n                                \n                                caret.set(wrapper, wrapper.textContent.length)\n                                node.remove()\n                            }\n\n                        }\n\n                        if (node.nodeType == 1) {\n\n                            this.highlight(node)\n                        }\n\n                    })\n                }\n            }\n        })\n    }\n\n    onPaste(e) {\n\n        // @TODO: paste logic should become as following:\n        // - get this.elm.innerText\n        // - sanitize the paste data (if the data is coming externally)\n        // - convert line breaks to sections (if the data is coming externally)\n        // - substite the selection (if any?, window.getSelection().toString()) from the innerText with the paste data\n        // - insert text in full editor\n        //  NOTE: to see if the paste data is coming externally we could create a copy event\n        //  inside the editor. When the copy data is the same as the paste, the data is internal\n\n        // this might not be the most efficient way to implement \n        // pasting but for now the lesser evil\n\n        const paste = e.clipboardData.getData('text/plain')\n        let node = e.path[0]\n        \n        if(window.getSelection() == paste) {\n\n            console.log('ok')\n        }\n\n        e.preventDefault\n\n\n    }\n\n    highlight(node) {\n\n        if (node) {\n\n            this.observer.disconnect()\n            const pos = caret.get(node)\n            node.innerHTML = Prism.highlight(node.innerText, Prism.languages.markdown)\n            caret.set(node, pos.start)\n            this.observer.observe(this.elm, observer)\n            this.trigger('change', this)\n        }\n    }\n\n    //@TODO: create different setText methods for paste and new text\n    setText(text) {\n\n        // create an empty element to paste the text in\n        // so it can be sanitized and escaped\n        const sanitizer = document.createElement('textarea')\n        sanitizer.value = text\n\n        // stop the observer while creating elements or the document will freeze!\n        this.observer.disconnect()\n        \n        const sections = sanitizer.value\n            .toString()\n            .split(/\\f/)\n        \n        const fragment = document.createDocumentFragment()\n\n\n        sections.forEach((section, index) => {\n            \n            const div = document.createElement('div')\n            div.classList.add(this.settings.sectionClass, 'markdown')\n            div.innerHTML = Prism.highlight(section, Prism.languages.markdown)\n            // div.innerText = section\n            // hljs.highlightBlock(div)\n            fragment.appendChild(div)\n        })\n\n        // remove all elements from the editor\n        while (this.elm.firstChild) {\n\n            this.elm.removeChild(this.elm.firstChild);\n        }\n\n        this.elm.appendChild(fragment)\n\n        this.observer.observe(this.elm, observer)\n    }\n\n    setNode(node, value) {\n\n        node.innerHTML = value\n    }\n\n    getHTML() {\n\n        return this.elm.innerHTML\n    }\n\n    inView() {\n    \n    }\n\n    getTextForStorage() {\n\n        let textBlocks = []\n\n        const nodes = Array.from(this.elm.childNodes)\n\n        nodes.forEach((e) => {\n\n            textBlocks.push(e.innerText)\n        })\n        \n        return textBlocks.join('\\f')\n    }\n\n    getText() {\n\n        return this.elm.innerText\n    }\n\n    getCaret() {\n\n        return caret.get(this.elm)\n    }\n\n    setStartingElement() {\n\n        // there are no children yet so create one\n        if(this.elm.firstChild == null) {\n\n            const div = document.createElement('div')\n            this.elm.appendChild(div)\n\n        // there is a first node but it's not a div\n        } else if (this.elm.firstChild.nodeName.toLowerCase() != 'div') {\n\n            const div = document.createElement('div')\n            this.elm.insertBefore(div, this.elm.firstChild)\n            this.elm.firstChild.nextSibling.remove()\n            caret.set(div, 0)\n        } \n    }\n\n    attach(e, callback) {\n\n        if (events.hasOwnProperty(e)) {\n\n            if (typeof callback == 'function') {\n\n                events[e] = callback\n\n            } else {\n\n                throw new Error('Event callback must be a function');\n            }\n\n        } else {\n\n            throw new Error('No support for the event: ' + e);\n        }\n    }\n\n    on(e, callback) {\n        \n        // arguments = e, callback \n        this.attach.apply(this, arguments)\n    }\n\n    trigger(e, ctx, args) {\n\n        if (events[e]) {\n            \n            events[e].call(ctx, args)\n        }\n\n    }\n}\n\nexport default Editor\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","export function extend(defaults, options) {\n\n    for ( var key in options ) {\n\n        if (Object.prototype.hasOwnProperty.call(options, key)) {\n\n            defaults[key] = options[key];\n        }\n    }\n\n    return defaults;\n}\n\nexport function isNode(node) {\n\n    return (\n        typeof Node === \"object\" ? node instanceof Node : \n        node && typeof node === \"object\" && typeof node.nodeType === \"number\" && typeof node.nodeName===\"string\"\n    );\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils.js\n **/","const parent = (node) => {\n\n    const range = window.getSelection().getRangeAt(0);\n\n    return range.startContainer.parentNode\n}\n\nconst createTreeWalker = (node) => {\n\n    return document.createTreeWalker(\n        node, // define the root\n        NodeFilter.SHOW_TEXT, // only textnodes\n        {\n            acceptNode: (node) => {\n\n                // by default accepts all nodes that are of type text\n                return NodeFilter.FILTER_ACCEPT\n            }\n        },\n        false\n    )\n}\n\nconst get = (node) => {\n\n    const treeWalker = createTreeWalker(node)\n    const sel = window.getSelection()\n\n    const pos = {\n\n        start: 0,\n        end: 0\n    }\n\n    let isBeyondStart = false\n\n    while(treeWalker.nextNode()) {\n        \n        // anchorNode is where the selection starts\n        if(!isBeyondStart && treeWalker.currentNode === sel.anchorNode) {\n\n            isBeyondStart = true\n\n            pos.start += sel.anchorOffset\n\n            if(sel.isCollapsed) {\n\n                pos.end = pos.start\n                break\n            }\n\n        } else if(!isBeyondStart) {\n\n            pos.start += treeWalker.currentNode.length\n        }\n\n        if(!sel.isCollapsed && treeWalker.currentNode === sel.focusNode) {\n\n            pos.end += sel.focusOffset\n            break\n\n        } else if(!sel.isCollapsed) {\n\n            pos.end += treeWalker.currentNode.length\n        }\n    }\n\n    return pos\n}\n\nconst set = (node, index) => {\n\n    const treeWalker = createTreeWalker(node)\n    let currentPos = 0\n\n    while(treeWalker.nextNode()) {\n\n        currentPos += treeWalker.currentNode.length\n\n        if (currentPos >= index) {\n\n            let prevValue = currentPos - treeWalker.currentNode.length\n            let offset = index - prevValue\n\n            const range = document.createRange()\n\n            range.setStart(treeWalker.currentNode, offset)\n            range.collapse(true)\n\n            const sel = window.getSelection()\n            sel.removeAllRanges()\n            sel.addRange(range)\n\n            break\n        }\n    }\n}\n\nexport default {\n    \n    get,\n    set,\n    parent\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/caret.js\n **/","\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t? self // if in worker\n\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function(){\n\n// Private helper vars\nvar lang = /\\blang(?:uage)?-(\\w+)\\b/i;\nvar uniqueId = 0;\n\nvar _ = _self.Prism = {\n\tutil: {\n\t\tencode: function (tokens) {\n\t\t\tif (tokens instanceof Token) {\n\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n\t\t\t} else if (_.util.type(tokens) === 'Array') {\n\t\t\t\treturn tokens.map(_.util.encode);\n\t\t\t} else {\n\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t}\n\t\t},\n\n\t\ttype: function (o) {\n\t\t\treturn Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n\t\t},\n\n\t\tobjId: function (obj) {\n\t\t\tif (!obj['__id']) {\n\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t}\n\t\t\treturn obj['__id'];\n\t\t},\n\n\t\t// Deep clone a language definition (e.g. to extend it)\n\t\tclone: function (o) {\n\t\t\tvar type = _.util.type(o);\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'Object':\n\t\t\t\t\tvar clone = {};\n\n\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn clone;\n\n\t\t\t\tcase 'Array':\n\t\t\t\t\t// Check for existence for IE8\n\t\t\t\t\treturn o.map && o.map(function(v) { return _.util.clone(v); });\n\t\t\t}\n\n\t\t\treturn o;\n\t\t}\n\t},\n\n\tlanguages: {\n\t\textend: function (id, redef) {\n\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\tfor (var key in redef) {\n\t\t\t\tlang[key] = redef[key];\n\t\t\t}\n\n\t\t\treturn lang;\n\t\t},\n\n\t\t/**\n\t\t * Insert a token before another token in a language literal\n\t\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n\t\t * we cannot just provide an object, we need anobject and a key.\n\t\t * @param inside The key (or language id) of the parent\n\t\t * @param before The key to insert before. If not provided, the function appends instead.\n\t\t * @param insert Object with the key/value pairs to insert\n\t\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n\t\t */\n\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\troot = root || _.languages;\n\t\t\tvar grammar = root[inside];\n\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tinsert = arguments[1];\n\n\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\tgrammar[newToken] = insert[newToken];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn grammar;\n\t\t\t}\n\n\t\t\tvar ret = {};\n\n\t\t\tfor (var token in grammar) {\n\n\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\tif (token == before) {\n\n\t\t\t\t\t\tfor (var newToken in insert) {\n\n\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update references in other language definitions\n\t\t\t_.languages.DFS(_.languages, function(key, value) {\n\t\t\t\tif (value === root[inside] && key != inside) {\n\t\t\t\t\tthis[key] = ret;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn root[inside] = ret;\n\t\t},\n\n\t\t// Traverse a language definition with Depth First Search\n\t\tDFS: function(o, callback, type, visited) {\n\t\t\tvisited = visited || {};\n\t\t\tfor (var i in o) {\n\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, null, visited);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, i, visited);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tplugins: {},\n\n\thighlightAll: function(async, callback) {\n\t\tvar env = {\n\t\t\tcallback: callback,\n\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t};\n\n\t\t_.hooks.run(\"before-highlightall\", env);\n\n\t\tvar elements = env.elements || document.querySelectorAll(env.selector);\n\n\t\tfor (var i=0, element; element = elements[i++];) {\n\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t}\n\t},\n\n\thighlightElement: function(element, async, callback) {\n\t\t// Find language\n\t\tvar language, grammar, parent = element;\n\n\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\tif (parent) {\n\t\t\tlanguage = (parent.className.match(lang) || [,''])[1].toLowerCase();\n\t\t\tgrammar = _.languages[language];\n\t\t}\n\n\t\t// Set language on the element, if not present\n\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\n\t\t// Set language on the parent, for styling\n\t\tparent = element.parentNode;\n\n\t\tif (/pre/i.test(parent.nodeName)) {\n\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\t}\n\n\t\tvar code = element.textContent;\n\n\t\tvar env = {\n\t\t\telement: element,\n\t\t\tlanguage: language,\n\t\t\tgrammar: grammar,\n\t\t\tcode: code\n\t\t};\n\n\t\t_.hooks.run('before-sanity-check', env);\n\n\t\tif (!env.code || !env.grammar) {\n\t\t\t_.hooks.run('complete', env);\n\t\t\treturn;\n\t\t}\n\n\t\t_.hooks.run('before-highlight', env);\n\n\t\tif (async && _self.Worker) {\n\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\tworker.onmessage = function(evt) {\n\t\t\t\tenv.highlightedCode = evt.data;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t};\n\n\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\tlanguage: env.language,\n\t\t\t\tcode: env.code,\n\t\t\t\timmediateClose: true\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\tcallback && callback.call(element);\n\n\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t_.hooks.run('complete', env);\n\t\t}\n\t},\n\n\thighlight: function (text, grammar, language) {\n\t\tvar tokens = _.tokenize(text, grammar);\n\t\treturn Token.stringify(_.util.encode(tokens), language);\n\t},\n\n\ttokenize: function(text, grammar, language) {\n\t\tvar Token = _.Token;\n\n\t\tvar strarr = [text];\n\n\t\tvar rest = grammar.rest;\n\n\t\tif (rest) {\n\t\t\tfor (var token in rest) {\n\t\t\t\tgrammar[token] = rest[token];\n\t\t\t}\n\n\t\t\tdelete grammar.rest;\n\t\t}\n\n\t\ttokenloop: for (var token in grammar) {\n\t\t\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tvar pattern = patterns[j],\n\t\t\t\t\tinside = pattern.inside,\n\t\t\t\t\tlookbehind = !!pattern.lookbehind,\n\t\t\t\t\tgreedy = !!pattern.greedy,\n\t\t\t\t\tlookbehindLength = 0,\n\t\t\t\t\talias = pattern.alias;\n\n\t\t\t\tpattern = pattern.pattern || pattern;\n\n\t\t\t\tfor (var i=0; i<strarr.length; i++) { // Don’t cache length as it changes during the loop\n\n\t\t\t\t\tvar str = strarr[i];\n\n\t\t\t\t\tif (strarr.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\tbreak tokenloop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpattern.lastIndex = 0;\n\n\t\t\t\t\tvar match = pattern.exec(str),\n\t\t\t\t\t    delNum = 1;\n\n\t\t\t\t\t// Greedy patterns can override/remove up to two previously matched tokens\n\t\t\t\t\tif (!match && greedy && i != strarr.length - 1) {\n\t\t\t\t\t\t// Reconstruct the original text using the next two tokens\n\t\t\t\t\t\tvar nextToken = strarr[i + 1].matchedStr || strarr[i + 1],\n\t\t\t\t\t\t    combStr = str + nextToken;\n\n\t\t\t\t\t\tif (i < strarr.length - 2) {\n\t\t\t\t\t\t\tcombStr += strarr[i + 2].matchedStr || strarr[i + 2];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Try the pattern again on the reconstructed text\n\t\t\t\t\t\tpattern.lastIndex = 0;\n\t\t\t\t\t\tmatch = pattern.exec(combStr);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index + (lookbehind ? match[1].length : 0);\n\t\t\t\t\t\t// To be a valid candidate, the new match has to start inside of str\n\t\t\t\t\t\tif (from >= str.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar to = match.index + match[0].length,\n\t\t\t\t\t\t    len = str.length + nextToken.length;\n\n\t\t\t\t\t\t// Number of tokens to delete and replace with the new match\n\t\t\t\t\t\tdelNum = 3;\n\n\t\t\t\t\t\tif (to <= len) {\n\t\t\t\t\t\t\tif (strarr[i + 1].greedy) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdelNum = 2;\n\t\t\t\t\t\t\tcombStr = combStr.slice(0, len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr = combStr;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(lookbehind) {\n\t\t\t\t\t\tlookbehindLength = match[1].length;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar from = match.index + lookbehindLength,\n\t\t\t\t\t    match = match[0].slice(lookbehindLength),\n\t\t\t\t\t    to = from + match.length,\n\t\t\t\t\t    before = str.slice(0, from),\n\t\t\t\t\t    after = str.slice(to);\n\n\t\t\t\t\tvar args = [i, delNum];\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\targs.push(before);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);\n\n\t\t\t\t\targs.push(wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\targs.push(after);\n\t\t\t\t\t}\n\n\t\t\t\t\tArray.prototype.splice.apply(strarr, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn strarr;\n\t},\n\n\thooks: {\n\t\tall: {},\n\n\t\tadd: function (name, callback) {\n\t\t\tvar hooks = _.hooks.all;\n\n\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\thooks[name].push(callback);\n\t\t},\n\n\t\trun: function (name, env) {\n\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i=0, callback; callback = callbacks[i++];) {\n\t\t\t\tcallback(env);\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar Token = _.Token = function(type, content, alias, matchedStr, greedy) {\n\tthis.type = type;\n\tthis.content = content;\n\tthis.alias = alias;\n\t// Copy of the full string this token was created from\n\tthis.matchedStr = matchedStr || null;\n\tthis.greedy = !!greedy;\n};\n\nToken.stringify = function(o, language, parent) {\n\tif (typeof o == 'string') {\n\t\treturn o;\n\t}\n\n\tif (_.util.type(o) === 'Array') {\n\t\treturn o.map(function(element) {\n\t\t\treturn Token.stringify(element, language, o);\n\t\t}).join('');\n\t}\n\n\tvar env = {\n\t\ttype: o.type,\n\t\tcontent: Token.stringify(o.content, language, parent),\n\t\ttag: 'span',\n\t\tclasses: ['token', o.type],\n\t\tattributes: {},\n\t\tlanguage: language,\n\t\tparent: parent\n\t};\n\n\tif (env.type == 'comment') {\n\t\tenv.attributes['spellcheck'] = 'true';\n\t}\n\n\tif (o.alias) {\n\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n\t\tArray.prototype.push.apply(env.classes, aliases);\n\t}\n\n\t_.hooks.run('wrap', env);\n\n\tvar attributes = '';\n\n\tfor (var name in env.attributes) {\n\t\tattributes += (attributes ? ' ' : '') + name + '=\"' + (env.attributes[name] || '') + '\"';\n\t}\n\n\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\n\n};\n\nif (!_self.document) {\n\tif (!_self.addEventListener) {\n\t\t// in Node.js\n\t\treturn _self.Prism;\n\t}\n \t// In worker\n\t_self.addEventListener('message', function(evt) {\n\t\tvar message = JSON.parse(evt.data),\n\t\t    lang = message.language,\n\t\t    code = message.code,\n\t\t    immediateClose = message.immediateClose;\n\n\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\tif (immediateClose) {\n\t\t\t_self.close();\n\t\t}\n\t}, false);\n\n\treturn _self.Prism;\n}\n\n//Get current script and highlight\nvar script = document.currentScript || [].slice.call(document.getElementsByTagName(\"script\")).pop();\n\nif (script) {\n\t_.filename = script.src;\n\n\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\n\t\tif(document.readyState !== \"loading\") {\n\t\t\trequestAnimationFrame(_.highlightAll, 0);\n\t\t}\n\t\telse {\n\t\t\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\n\t\t}\n\t}\n}\n\nreturn _self.Prism;\n\n})();\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n\tglobal.Prism = Prism;\n}\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n\t'comment': /<!--[\\w\\W]*?-->/,\n\t'prolog': /<\\?[\\w\\W]+?\\?>/,\n\t'doctype': /<!DOCTYPE[\\w\\W]+?>/,\n\t'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=.$<]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\\\1|\\\\?(?!\\1)[\\w\\W])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /[=>\"']/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': /&#?[\\da-z]{1,8};/i\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function(env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nPrism.languages.xml = Prism.languages.markup;\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\nPrism.languages.css = {\n\t'comment': /\\/\\*[\\w\\W]*?\\*\\//,\n\t'atrule': {\n\t\tpattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n\t\tinside: {\n\t\t\t'rule': /@[\\w-]+/\n\t\t\t// See rest below\n\t\t}\n\t},\n\t'url': /url\\((?:([\"'])(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1|.*?)\\)/i,\n\t'selector': /[^\\{\\}\\s][^\\{\\};]*?(?=\\s*\\{)/,\n\t'string': /(\"|')(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n\t'important': /\\B!important\\b/i,\n\t'function': /[-a-z0-9]+(?=\\()/i,\n\t'punctuation': /[(){};:]/\n};\n\nPrism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'style': {\n\t\t\tpattern: /(<style[\\w\\W]*?>)[\\w\\W]*?(?=<\\/style>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.css,\n\t\t\talias: 'language-css'\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('inside', 'attr-value', {\n\t\t'style-attr': {\n\t\t\tpattern: /\\s*style=(\"|').*?\\1/i,\n\t\t\tinside: {\n\t\t\t\t'attr-name': {\n\t\t\t\t\tpattern: /^\\s*style/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\t'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /.+/i,\n\t\t\t\t\tinside: Prism.languages.css\n\t\t\t\t}\n\t\t\t},\n\t\t\talias: 'language-css'\n\t\t}\n\t}, Prism.languages.markup.tag);\n}\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\tpunctuation: /(\\.|\\\\)/\n\t\t}\n\t},\n\t'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n\t'boolean': /\\b(true|false)\\b/,\n\t'function': /[a-z0-9_]+(?=\\()/i,\n\t'number': /\\b-?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+-]?\\d+)?)\\b/i,\n\t'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'keyword': /\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|0b[01]+|0o[0-7]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|Infinity)\\b/,\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*(?=\\()/i\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\\\\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'template-string': {\n\t\tpattern: /`(?:\\\\\\\\|\\\\?[^\\\\])*?`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /\\$\\{[^}]+\\}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t}\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'script': {\n\t\t\tpattern: /(<script[\\w\\W]*?>)[\\w\\W]*?(?=<\\/script>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript,\n\t\t\talias: 'language-javascript'\n\t\t}\n\t});\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n\tif (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {\n\t\treturn;\n\t}\n\n\tself.Prism.fileHighlight = function() {\n\n\t\tvar Extensions = {\n\t\t\t'js': 'javascript',\n\t\t\t'py': 'python',\n\t\t\t'rb': 'ruby',\n\t\t\t'ps1': 'powershell',\n\t\t\t'psm1': 'powershell',\n\t\t\t'sh': 'bash',\n\t\t\t'bat': 'batch',\n\t\t\t'h': 'c',\n\t\t\t'tex': 'latex'\n\t\t};\n\n\t\tif(Array.prototype.forEach) { // Check to prevent error in IE8\n\t\t\tArray.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {\n\t\t\t\tvar src = pre.getAttribute('data-src');\n\n\t\t\t\tvar language, parent = pre;\n\t\t\t\tvar lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\t\t\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\t\t\tparent = parent.parentNode;\n\t\t\t\t}\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tlanguage = (pre.className.match(lang) || [, ''])[1];\n\t\t\t\t}\n\n\t\t\t\tif (!language) {\n\t\t\t\t\tvar extension = (src.match(/\\.(\\w+)$/) || [, ''])[1];\n\t\t\t\t\tlanguage = Extensions[extension] || extension;\n\t\t\t\t}\n\n\t\t\t\tvar code = document.createElement('code');\n\t\t\t\tcode.className = 'language-' + language;\n\n\t\t\t\tpre.textContent = '';\n\n\t\t\t\tcode.textContent = 'Loading…';\n\n\t\t\t\tpre.appendChild(code);\n\n\t\t\t\tvar xhr = new XMLHttpRequest();\n\n\t\t\t\txhr.open('GET', src, true);\n\n\t\t\t\txhr.onreadystatechange = function () {\n\t\t\t\t\tif (xhr.readyState == 4) {\n\n\t\t\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\t\t\tcode.textContent = xhr.responseText;\n\n\t\t\t\t\t\t\tPrism.highlightElement(code);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (xhr.status >= 400) {\n\t\t\t\t\t\t\tcode.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcode.textContent = '✖ Error: File does not exist or is empty';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\txhr.send(null);\n\t\t\t});\n\t\t}\n\n\t};\n\n\tdocument.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);\n\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/prism.js\n ** module id = 3\n ** module chunks = 0\n **/","Prism.languages.markdown = Prism.languages.extend('markup', {});\nPrism.languages.insertBefore('markdown', 'prolog', {\n\t'blockquote': {\n\t\t// > ...\n\t\tpattern: /^>(?:[\\t ]*>)*/m,\n\t\talias: 'punctuation'\n\t},\n\t'code': [\n\t\t{\n\t\t\t// Prefixed by 4 spaces or 1 tab\n\t\t\tpattern: /^(?: {4}|\\t).+/m,\n\t\t\talias: 'keyword'\n\t\t},\n\t\t{\n\t\t\t// `code`\n\t\t\t// ``code``\n\t\t\tpattern: /``.+?``|`[^`\\n]+`/,\n\t\t\talias: 'keyword'\n\t\t}\n\t],\n\t'title': [\n\t\t{\n\t\t\t// title 1\n\t\t\t// =======\n\n\t\t\t// title 2\n\t\t\t// -------\n\t\t\tpattern: /\\w+.*(?:\\r?\\n|\\r)(?:==+|--+)/,\n\t\t\talias: 'important',\n\t\t\tinside: {\n\t\t\t\tpunctuation: /==+$|--+$/\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t// # title 1\n\t\t\t// ###### title 6\n\t\t\tpattern: /(^\\s*)#+.+/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'important',\n\t\t\tinside: {\n\t\t\t\tpunctuation: /^#+|#+$/\n\t\t\t}\n\t\t}\n\t],\n\t'hr': {\n\t\t// ***\n\t\t// ---\n\t\t// * * *\n\t\t// -----------\n\t\tpattern: /(^\\s*)([*-])([\\t ]*\\2){2,}(?=\\s*$)/m,\n\t\tlookbehind: true,\n\t\talias: 'punctuation'\n\t},\n\t'list': {\n\t\t// * item\n\t\t// + item\n\t\t// - item\n\t\t// 1. item\n\t\tpattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n\t\tlookbehind: true,\n\t\talias: 'punctuation'\n\t},\n\t'url-reference': {\n\t\t// [id]: http://example.com \"Optional title\"\n\t\t// [id]: http://example.com 'Optional title'\n\t\t// [id]: http://example.com (Optional title)\n\t\t// [id]: <http://example.com> \"Optional title\"\n\t\tpattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n\t\tinside: {\n\t\t\t'variable': {\n\t\t\t\tpattern: /^(!?\\[)[^\\]]+/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t'string': /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n\t\t\t'punctuation': /^[\\[\\]!:]|[<>]/\n\t\t},\n\t\talias: 'url'\n\t},\n\t'bold': {\n\t\t// **strong**\n\t\t// __strong__\n\n\t\t// Allow only one line break\n\t\tpattern: /(^|[^\\\\])(\\*\\*|__)(?:(?:\\r?\\n|\\r)(?!\\r?\\n|\\r)|.)+?\\2/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /^\\*\\*|^__|\\*\\*$|__$/\n\t\t}\n\t},\n\t'italic': {\n\t\t// *em*\n\t\t// _em_\n\n\t\t// Allow only one line break\n\t\tpattern: /(^|[^\\\\])([*_])(?:(?:\\r?\\n|\\r)(?!\\r?\\n|\\r)|.)+?\\2/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /^[*_]|[*_]$/\n\t\t}\n\t},\n\t'url': {\n\t\t// [example](http://example.com \"Optional title\")\n\t\t// [example] [id]\n\t\tpattern: /!?\\[[^\\]]+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)| ?\\[[^\\]\\n]*\\])/,\n\t\tinside: {\n\t\t\t'variable': {\n\t\t\t\tpattern: /(!?\\[)[^\\]]+(?=\\]$)/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/\n\t\t\t}\n\t\t}\n\t}\n});\n\nPrism.languages.markdown['bold'].inside['url'] = Prism.util.clone(Prism.languages.markdown['url']);\nPrism.languages.markdown['italic'].inside['url'] = Prism.util.clone(Prism.languages.markdown['url']);\nPrism.languages.markdown['bold'].inside['italic'] = Prism.util.clone(Prism.languages.markdown['italic']);\nPrism.languages.markdown['italic'].inside['bold'] = Prism.util.clone(Prism.languages.markdown['bold']);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-markdown.js\n ** module id = 4\n ** module chunks = 0\n **/","(function () {\n\n\tif (typeof self === 'undefined' || !self.Prism || !self.document || !document.createRange) {\n\t\treturn;\n\t}\n\n\tPrism.plugins.KeepMarkup = true;\n\n\tPrism.hooks.add('before-highlight', function (env) {\n\t\tif (!env.element.children.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar pos = 0;\n\t\tvar data = [];\n\t\tvar f = function (elt, baseNode) {\n\t\t\tvar o = {};\n\t\t\tif (!baseNode) {\n\t\t\t\t// Clone the original tag to keep all attributes\n\t\t\t\to.clone = elt.cloneNode(false);\n\t\t\t\to.posOpen = pos;\n\t\t\t\tdata.push(o);\n\t\t\t}\n\t\t\tfor (var i = 0, l = elt.childNodes.length; i < l; i++) {\n\t\t\t\tvar child = elt.childNodes[i];\n\t\t\t\tif (child.nodeType === 1) { // element\n\t\t\t\t\tf(child);\n\t\t\t\t} else if(child.nodeType === 3) { // text\n\t\t\t\t\tpos += child.data.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!baseNode) {\n\t\t\t\to.posClose = pos;\n\t\t\t}\n\t\t};\n\t\tf(env.element, true);\n\n\t\tif (data && data.length) {\n\t\t\t// data is an array of all existing tags\n\t\t\tenv.keepMarkup = data;\n\t\t}\n\t});\n\n\tPrism.hooks.add('after-highlight', function (env) {\n\t\tif(env.keepMarkup && env.keepMarkup.length) {\n\n\t\t\tvar walk = function (elt, nodeState) {\n\t\t\t\tfor (var i = 0, l = elt.childNodes.length; i < l; i++) {\n\n\t\t\t\t\tvar child = elt.childNodes[i];\n\n\t\t\t\t\tif (child.nodeType === 1) { // element\n\t\t\t\t\t\tif (!walk(child, nodeState)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (child.nodeType === 3) { // text\n\t\t\t\t\t\tif(!nodeState.nodeStart && nodeState.pos + child.data.length > nodeState.node.posOpen) {\n\t\t\t\t\t\t\t// We found the start position\n\t\t\t\t\t\t\tnodeState.nodeStart = child;\n\t\t\t\t\t\t\tnodeState.nodeStartPos = nodeState.node.posOpen - nodeState.pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nodeState.nodeStart && nodeState.pos + child.data.length >= nodeState.node.posClose) {\n\t\t\t\t\t\t\t// We found the end position\n\t\t\t\t\t\t\tnodeState.nodeEnd = child;\n\t\t\t\t\t\t\tnodeState.nodeEndPos = nodeState.node.posClose - nodeState.pos;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnodeState.pos += child.data.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (nodeState.nodeStart && nodeState.nodeEnd) {\n\t\t\t\t\t\t// Select the range and wrap it with the clone\n\t\t\t\t\t\tvar range = document.createRange();\n\t\t\t\t\t\trange.setStart(nodeState.nodeStart, nodeState.nodeStartPos);\n\t\t\t\t\t\trange.setEnd(nodeState.nodeEnd, nodeState.nodeEndPos);\n\t\t\t\t\t\tnodeState.node.clone.appendChild(range.extractContents());\n\t\t\t\t\t\trange.insertNode(nodeState.node.clone);\n\t\t\t\t\t\trange.detach();\n\n\t\t\t\t\t\t// Process is over\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\t// For each tag, we walk the DOM to reinsert it\n\t\t\tenv.keepMarkup.forEach(function (node) {\n\t\t\t\twalk(env.element, {\n\t\t\t\t\tnode: node,\n\t\t\t\t\tpos: 0\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t});\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/plugins/keep-markup/prism-keep-markup.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}